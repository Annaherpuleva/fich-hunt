# Аудит фронтенда и рекомендации по переходу с «контрактной» модели на backend/API

## Контекст
Сейчас фронтенд смешивает две модели:
1. **Web2/server-driven** (через `/api/v1/...`).
2. **Web3/контракт-driven** (TON wallet, lamports/SOL, тексты про smart contract).

Если по продуктовой логике теперь **источник истины — сервер + БД**, лучше сделать последовательную миграцию и убрать «контрактные» допущения из UI/UX, названий и текстов.

---

## Что уже видно в `client/src`

### 1) Юридические и support-тексты всё ещё про смарт-контракт
- `pages/TermsPage.tsx`: секция целиком описывает работу через smart contract.
- `pages/ContactsPage.tsx`: формулировки «interface issue or suspect incorrect smart‑contract behaviour».

**Риск:** пользователь получает неверную юридическую/операционную модель, а саппорт — нерелевантные тикеты.

### 2) Конфигурация и нейминг привязаны к «contract/program»
- `config/contract.ts`, `PROGRAM_ID`, `getProgram`, `deriveOceanPda`.

**Риск:** даже если фактическая логика на backend, кодовая база подсказывает разработчикам противоположное и увеличивает вероятность регрессий при изменениях.

### 3) В доменной логике и UI сильная привязка к lamports/SOL
- `core/constants.ts`: `LAMPORTS_PER_SOL`, `MIN_FEED_LAMPORTS`, `MIN_DEPOSIT_LAMPORTS`.
- `pages/FishPage.tsx`, `pages/StartGamePage.tsx`: расчёты и валидации через lamports/SOL, сообщения про контракт.

**Риск:** неверные единицы измерения и неконсистентность, если backend уже оперирует своими денежными единицами/правилами.

### 4) Кошелёк глубоко прошит в основной UX
- `main.tsx`: `TonConnectUIProvider`.
- `wallet/*`, `components/Header.tsx`, `components/WalletDropdown.tsx`, `components/ProfileButton.tsx` и др.

**Риск:** тяжело развивать классическую auth-модель (telegram/web auth/session) и бизнес-флоу без кошелька.

### 5) Смешанный data layer
- Есть API-слой (`shared/api/*`, `features/ocean/api/ocean.api.ts`), но рядом остаются блокчейн-специфичные абстракции.

**Риск:** раздвоенная архитектура, дублирование правил и сложные баги из-за разных источников данных.

---

## Рекомендованный план миграции (без поломки продакшена)

### Этап 1 — Тексты и коммуникация (быстрый, низкий риск)
1. Убрать из UI/доков упоминания smart contract там, где логика уже серверная.
2. Заменить формулировки на «игровой сервер», «backend-обработка», «база данных», «транзакция в системе».
3. Обновить Terms/Privacy/Contacts синхронно, чтобы не было конфликтующих юридических текстов.

### Этап 2 — Доменные единицы и типы
1. Ввести нейтральные типы денег: `MoneyAtomic`, `CurrencyCode` или `GameAmount`.
2. Убрать из UI прямые `lamports`/`SOL`-конверсии; форматировать суммы через единый helper.
3. Правила (минимальный депозит/комиссия) отдавать с backend-конфига (`/api/v1/config`).

### Этап 3 — Конфиг и нейминг
1. `config/contract.ts` переименовать в `config/runtimeGame.ts` (или аналог).
2. `PROGRAM_ID`, `getProgram` и т.д. заменить на backend-термины (`serviceId`, `tenantId`, `oceanConfig`, ...), если они реально нужны.
3. Временный compatibility-слой оставить на 1–2 релиза (deprecated wrappers), потом удалить.

### Этап 4 — Авторизация и идентичность
1. Разделить сущности: `UserIdentity` (id, authProvider, displayName) и `WalletIdentity` (walletAddress, network, walletProvider).
2. Всегда создавать/обновлять пользователя как основную запись, а кошелёк хранить как связанную запись (`user -> wallets`).
3. Не форсировать wallet connect для всех действий по умолчанию: решать по бизнес-правилам.
4. Если по продукту кошелёк обязателен для части сценариев (например, платежи/вывод), требовать его **только** в этих сценариях.
5. Если по продукту кошелёк обязателен везде, всё равно оставить разделение моделей, чтобы упростить дальнейшую эволюцию auth-логики.

### Этап 5 — Data layer и источники истины
1. Формально зафиксировать: единственный source of truth — backend API.
2. Любые «локальные зеркала правил» (комментарии «mirror of on-chain») заменить на «fetched from backend config».
3. Для событий охоты/прибыли — polling/SSE/WebSocket из backend, без псевдо-onchain терминологии.

---


### Этап 6 — Выплаты, claim и наблюдаемость settlement-пайплайна
1. Базовый режим выплат: auto-settlement на backend сразу после подтвержденного статуса действия.
2. `Claim` оставить только как fallback/recovery (не как основной happy-path).
3. Backend settlement должен быть идемпотентным по ключу операции (`tx hash + action id`).
4. Фронтенд показывает прогресс из backend-событий (polling/SSE/WebSocket), а не вычисляет итог локально.

---

## Приоритетная очередь файлов для рефакторинга

1. **Срочно (контент/коммуникация):**
   - `pages/TermsPage.tsx`
   - `pages/ContactsPage.tsx`
2. **Домен и расчёты:**
   - `core/constants.ts`
   - `pages/StartGamePage.tsx`
   - `pages/FishPage.tsx`
3. **Архитектурный нейминг:**
   - `config/contract.ts`
4. **Identity/UI доступа:**
   - `main.tsx`
   - `wallet/*`
   - `components/Header.tsx`, `components/WalletDropdown.tsx`

---

## Как лучше поступить practically

Оптимальная стратегия: **сначала контент + термины, затем доменные типы денег, затем постепенный вынос wallet в optional feature-flag**.

Это даст:
- быстрый видимый результат без риска сломать геймплей;
- снижение путаницы у пользователей и команды;
- контролируемую миграцию без большого «big bang».

---

## Что сделать следующим шагом

Предлагаю в следующем PR выполнить «Этап 1» полностью:
- переписать `TermsPage` и `ContactsPage` под серверную модель;
- пройтись по пользовательским error-сообщениям (`StartGamePage`, `FishPage`, `TxOverlay`) и убрать формулировки про контракт;
- добавить чек-лист терминов (запрещённые: `smart contract`, `programId`, `on-chain` в UI-текстах).

## Decision record (обязательно к применению)

- **Single source of truth:** backend API является единственным источником истины для состояния, правил, балансов, начислений и статусов событий.
- **Rule source:** любые клиентские правила берутся как `fetched from backend config`; локальные «зеркала on-chain правил» не допускаются.
- **Event source:** события охоты/прибыли приходят из backend-каналов (polling/SSE/WebSocket), без on-chain терминологии в UI.
- **User confirmation:** `action` и `feeding` выполняются только после подтверждения транзакции пользователем через TON Connect.
- **Settlement policy:** начисления после подтвержденных действий выполняются автоматически backend-сервисом; ручной `Claim` разрешён только как fallback/recovery.
- **UX status chain:** UI обязан показывать последовательность `ожидает подтверждения` → `подтверждено в сети` → `зачислено backend`.

## Рекомендуемая бизнес-логика выплат и claim

- **Базовый режим:** auto-settlement. После подтверждения TON Connect транзакции backend сам фиксирует результат действия и сразу проводит начисление на кошелёк/баланс по правилам игры.
- **Claim как fallback:** отдельная кнопка `Claim` нужна только для восстановления в редких сбоях (например, таймаут индексации или временная недоступность обработчика).
- **Идемпотентность:** backend должен выполнять начисление по уникальному ключу операции (tx hash + action id), чтобы исключить двойные выплаты.
- **Наблюдаемость:** фронтенд подписывается на backend-события (polling/SSE/WebSocket) и отображает прогресс обработки, а не вычисляет итог локально.

